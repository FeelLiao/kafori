# 拓展插件集成

kafori平台支持两种插件的集成，一种是**转录组数据分析及可视化插件**，用于实现转录组数据的分析和可视化；另一种是**下载数据源插件**，用于实现服务端数据的下载和导出。本文档介绍了这两种插件的集成方式。

## 1. 转录组数据分析及可视化插件

分析插件用于实现特定的分析/可视化功能。后端提供统一基类与注册机制，插件只需定义参数模型、实现 run 方法并准备对应 R 脚本，即可通过 `/transcripts/analysis*` 接口被调用。

> [!IMPORTANT]
> 如果是Python直接实现对应分析和可视化，不需要R脚本来处理数据，也可以通过继承同样的基类来实现，本文档同样适用。纯Python实现时，需要重写init方法并不使用R相关的变量，run方法内直接处理pandas DataFrame 并返回结果即可。

相关源码:
- 基类与注册表: `backend/analysis/framework.py`
- R 执行与进程池: `backend/analysis/analysis_base.py`
- 示例插件: `backend/analysis/plugins/pca.py`
- 示例 R 脚本: `backend/analysis/scripts/pca.py`

### 1.1 架构与数据流

- 基类: `BaseAnalysis`
  - 关键属性:
    - `id: str` 分析唯一标识（由装饰器赋值）
    - `title: str` 展示名
    - `input_type: InputData` 输入数据类型: `tpm` 或 `counts`
    - `Params: BaseAnalysisParams` Pydantic 参数模型（会生成 JSON Schema）
    - `gene_filter: bool` 是否需要基因过滤
  - 初始化: 注入 pandas DataFrame（后端按 `input_type` 抓取并转换）、参数、R 执行器
  - 工具方法:
    - `py2r(df)`/`r2py(obj)`：pandas 与 R 对象互转
    - `str_to_base64(s)`：将 SVG 文本转 base64 字符串
- 注册机制: `@register_analysis("<analysis_id>")` 将类注册进全局表
- 目录聚合: `catalog()` → `[ {id,title,input_type,params_schema}, ... ]`
- 执行: 路由拿到插件类 → 实例化 → `await plugin.run()`
- R 执行器: `RProcessorPoolMP`
  - 多进程池执行 R 代码（默认 60s 超时、最多 2 次尝试）
  - 每个进程初始化 R 环境: 预加载 `tidyverse`、`svglite`，并提供
    - `plot_to_raw(plot_obj, width, height)` → 返回 SVG 文本
  - 每次任务在隔离环境中运行，结束后清理 `rm(list=ls())`

### 1.2 开发步骤（最小示例）

1) 新建 R 脚本（或内嵌字符串）
```r
# filepath: backend/analysis/scripts/my_analysis.R  (或 Py 文件内用三引号字符串)
suppressPackageStartupMessages({
  library(ggplot2)
  # 按需加载其他包（示例：FactoMineR、ggrepel、dplyr、stringr等）
})

# 约定: 后端会注入下列变量之一
# - expression_tpm: R data.frame（行=gene, 列=sample, 含 gene_id 列）
# - 或 expression_counts: 同上
# 以及 width, height, 以及你在 run() 传入的自定义参数

gene_df <- expression_tpm |>
  remove_rownames() |>
  mutate(across(-gene_id, ~ suppressWarnings(as.numeric(.x)))) |>
  column_to_rownames("gene_id")

# 简单示例：统计样本总表达
sample_sum <- colSums(gene_df)
res_tbl <- tibble::tibble(sample = names(sample_sum), total = as.numeric(sample_sum))

# 演示绘图（可选）
p <- ggplot(res_tbl, aes(sample, total)) + geom_col() + theme_bw()
svg_raw <- plot_to_raw(p, width = width, height = height)

# 必须返回一个带命名元素的 list
list(
  table = res_tbl,
  plot = svg_raw
)
```

2) 新建插件类并注册

```python
// filepath: backend/analysis/plugins/my_analysis.py
from typing import Any, Dict
from pydantic import Field
from backend.analysis.framework import BaseAnalysis, BaseAnalysisParams, InputData, register_analysis
from backend.analysis.framework import ParamsType
from backend.analysis.scripts.my_analysis import my_analysis_code  # 若使用内嵌字符串

class MyParams(BaseAnalysisParams):
    min_expr: float = Field(0.0, ge=0, description="Filter threshold",
    json_schema_extra={"TYPE": ParamsType.number})

@register_analysis("my_analysis")
class MyAnalysis(BaseAnalysis):
    title = "My Analysis"
    input_type = InputData.tpm  # 或 InputData.counts
    Params = MyParams

    async def run(self) -> Dict[str, Any]:
        # 将 pandas DF 转为 R 对象已在 BaseAnalysis.__init__ 完成: self.rdata
        res = await self.rproc.run_analysis(
            my_analysis_code,
            expression_tpm=self.rdata,   # 或 expression_counts=self.rdata
            width=self.params.width,
            height=self.params.height,
            # 自定义参数需要在这里传入，R中会保存成对应名字的变量，可在R脚本中直接使用
            min_expr=float(self.params.min_expr),
        )
        # 从 R list 中取结果，详细参考 rpy2 文档
        svg_raw = res.rx2("plot")[0]
        table_df = self.r2py(res.rx2("table"))  # 转回 pandas

        return {
            "meta": {"title": self.title},
            "plots": [
                {
                    "format": "image/svg+xml;base64",
                    "title": "Summary",
                    "data": self.str_to_base64(svg_raw),
                }
            ],
            "tables": {"summary": table_df.to_dict(orient="records")},
        }
```

3) 确保在应用启动时导入你的插件模块，使注册生效
```python
# 例如在分析路由装配模块中
import backend.analysis.plugins.my_analysis  # noqa: F401
```

4) 前端使用
- GET `/transcripts/analysis/catalog` 可见你的插件（由 `params_schema` 驱动动态表单）
- POST `/transcripts/analysis` 传入 `analysis: "my_analysis"` 与参数，即可运行

### 1.3 R 端脚本编写约定与技巧

- 数据输入变量名：
  - TPM: `expression_tpm`
  - Raw counts: `expression_counts`
  - 两者均为 R data.frame，包含一列 `gene_id`，其余列为样本
- 绘图输出：
  - 使用已注入的 `plot_to_raw(plot, width, height)` 生成 SVG 文本
  - Python 端将其 base64 编码并以 `"image/svg+xml;base64"` 形式返回
- 包加载：
  - 运行时环境已预加载 `tidyverse` 与 `svglite`
  - 其他包（如 `FactoMineR`、`limma`、`edgeR`、`ggrepel`）需自行 `library(...)`
- 返回值：
  - 必须是命名 list，如 `list(t1=..., t2=..., p="...svg...")`
  - 表格返回 data.frame/tibble，Python 端用 `r2py()` 转换
- 性能与健壮性：
  - 对输入做类型/范围检查（示例：counts 不能为负）
  - 数据量大时尽量在 R 端先过滤/聚合再返回，避免庞大 JSON

### 1.4 参数定义与校验

- 继承 `BaseAnalysisParams`，可复用通用绘图参数 `width/height`
- 自定义字段时，请使用 `json_schema_extra` 指定前端表单类型，**只能是以下类型的一种**:
  - 数字: `{"TYPE": ParamsType.number}`
  - 字符串: `{"TYPE": ParamsType.string}`
  - 枚举: `{"TYPE": ParamsType.enum, "ENUM": [list of values]}`
- 使用 Pydantic 字段约束（如 `ge/le`）进行校验，Schema 将在目录接口中暴露
- 后端会将 `Params` 实例注入插件，`run()` 中通过 `self.params.<field>` 使用

示例（见 PCA 插件）：
```python
class PCAParams(BaseAnalysisParams):
    ncps: int = Field(5, ge=2, le=20, description="Number of principal components",
    json_schema_extra={"TYPE": ParamsType.number})
```

### 1.5 运行与错误处理

- 执行器：`RProcessorPoolMP` 多进程执行，默认:
  - 超时: 60s
  - 重试: 最多 2 次
  - 隔离: 任务结束后清理 R 环境
- 错误传播：
  - R 运行错误将封装为 `Exception("R error: <message>")` 抛出
  - 路由层捕获后返回统一错误结构（见 API 文档）
- 性能建议：
  - 控制一次分析的样本和基因规模
  - 复杂分析可在 R 端用 `filterByExpr`、`rowSums` 等预筛选

### 1.6 参考实现（PCA）

- 插件：`backend/analysis/plugins/pca.py`
- 脚本：`backend/analysis/scripts/pca.py`
  - 使用 `FactoMineR` 计算、`ggrepel` 标注，输入为 `expression_tpm`
  - 返回:
    - `pca_plot` → SVG 原文（Python 端转 base64）
    - `pca_eig`、`pca_sample` → 表格

## 2. 下载数据源插件（Download Providers）

下载数据源插件用于向前端暴露可下载的数据清单（catalog）并响应实际文件下载。平台提供统一基类与注册机制，第三方仅需实现两个方法并完成注册即可接入 `/download/*` 接口。

相关源码：
- 基类与注册表：`backend/api/dl_providers.py`
- 示例实现（读取配置路径）：`backend/api/download/config_download.py`
- 路由装配：`backend/routers/download_routers.py`

### 2.1 架构与调用流程

- Base 类：`class BaseDownload(ABC)`，关键点：
  - 类属性：
    - `classes: str` 下载类别名称（如 `Genomic Data`）
    - `items: dict[str, Any]` 目录缓存（类级别）
  - 必实现方法：
    - `catalog(self) -> dict[str, Any]`
      - 返回该类别下的条目字典：`{"item_key": {"filename": str, "media_type": str}}`
      - 出于安全考虑，不应包含服务器物理路径
    - `response(self, filename: str)`
      - 根据 `filename` 返回 `FileResponse` 或 `StreamingResponse`
  - 并发与缓存：首次访问时自动加载目录到类级缓存；`refresh_items()` 可主动刷新

- 注册机制：`@register_download("<CategoryName>")` 装饰 Provider 子类，即可注册到全局表
- 聚合目录：`get_catalog()` → `[ {"classes": <CategoryName>, "items": {...}}, ... ]`
- 下载分发：`handle_download(classes)` → 返回对应 Provider 类

- 路由：
  - `GET /download/catalog` → 返回聚合目录（统一 `Result` 结构）
  - `POST /download/{classes}/{filename}` → 分发至 Provider 的 `response()`

### 2.2 最小骨架示例

```python
# backend/api/download/my_download.py
from pathlib import Path
import mimetypes
from fastapi.responses import FileResponse
from backend.api.dl_providers import BaseDownload, register_download

ROOT = Path("/data/my_exports").resolve()

@register_download("My Exports")
class MyExportDownload(BaseDownload):
    def catalog(self) -> dict[str, dict[str, str]]:
        items: dict[str, dict[str, str]] = {}
        for p in ROOT.glob("*.zip"):
            media = mimetypes.guess_type(str(p))[0] or "application/octet-stream"
            items[p.stem] = {
                "filename": p.name,       # 用于下载路径
                "media_type": media,      # 用于 Content-Type
            }
        return items

    def response(self, filename: str) -> FileResponse:
        p = ROOT / filename
        if not p.is_file():
            raise FileNotFoundError(f"File not found: {p}")
        media = mimetypes.guess_type(str(p))[0] or "application/octet-stream"
        return FileResponse(path=str(p), filename=filename, media_type=media)
```

激活（确保模块被导入以执行注册）：

```python
# backend/routers/download_routers.py
import backend.api.download.my_download  # noqa: F401  # 仅导入用于注册
```

随后，`GET /download/catalog` 将包含：

```json
{
  "code": 0,
  "message": "Success",
  "data": [
    {
      "classes": "My Exports",
      "items": {
        "dataset_2024": {
          "filename": "dataset_2024.zip",
          "media_type": "application/zip"
        }
      }
    }
  ]
}
```

下载某文件：

```bash
curl -X POST "http://localhost:8000/download/My%20Exports/dataset_2024.zip" -o dataset_2024.zip
```

### 2.3 基于配置的内置实现（GenomeDownload）

文件：`backend/api/download/config_download.py`

设计要点：
- 从 `config.download` 读取 name→path 的映射；将相对路径基于仓库根目录解析为绝对路径
- `catalog()` 对外仅返回 `filename` 与 `media_type`（过滤掉物理 `path`）
- 类属性 `download_dict` 保留包含 `path` 的原始元数据，供 `response()` 使用
- `response(filename)` 在缓存中匹配文件名，读取对应 `path` 并返回 `FileResponse`

示意：

```text
settings.yaml → config.download: { genome_fasta: path/to.fa.gz, genome_annotation: path/to.gtf.gz }
  │
  └─ GenomeDownload.config_phase() → { name: { filename, media_type, path } }
       │
       ├─ .catalog() → strip(path) → { name: { filename, media_type } }  # 给前端
       └─ .response(filename) → 查缓存(path) → FileResponse
```

### 2.4 规范与注意事项

- 返回结构：`catalog()` 必须返回 `dict`，键为条目标识，值对象至少包含 `filename` 与 `media_type`。
- 安全：不在对外目录暴露物理路径；内部可在类属性中缓存供 `response()` 使用。
- URL 编码：`classes` 可能包含空格（如 `Genomic Data`），前端应进行 URL 编码（`Genomic%20Data`）。
- MIME 类型：建议用 `mimetypes.guess_type()` 推断；失败回退 `application/octet-stream`。
- 错误返回（当前路由实现用统一 JSON 包裹，HTTP 200）：
  - 未注册类别 → `Unknown download provider: <classes>`
  - 未知文件名 → `Unknown filename: <filename>`
  - 文件不存在 → `File not found: <path>`
- 并发与缓存：`BaseDownload` 使用类级缓存与 RLock；如目录有变更，可调用 `YourProvider.refresh_items()` 刷新。
- 生效时机：务必在应用启动阶段 import 你的 Provider 模块，使 `@register_download` 执行完成注册。

### 2.5 自检清单（建议）

- 目录接口：`GET /download/catalog` 返回包含你的 `classes`，`items` 结构正确。
- 下载接口：`POST /download/{classes}/{filename}` 可以成功下载；响应头包含合理的 `Content-Type` 与 `Content-Disposition`。
- 错误路径：
  - 指定未注册 `classes`、不存在的 `filename`、或删除目标文件，确认错误信息符合预期。
- 并发：并发访问 `catalog` 不应导致阻塞或重复计算异常。
